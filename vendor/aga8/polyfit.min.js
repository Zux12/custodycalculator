
// Minimal polyfit stub for AGA8 bundles
(function(global){
  function polyfit(x, y, degree){
    // Very simple least squares polyfit (for completeness)
    // In most AGA8 builds it's used only for small calibrations
    const n = x.length;
    const X = [];
    const Y = [];
    for (let i=0;i<n;i++){
      const row = [];
      for (let j=0;j<=degree;j++) row.push(Math.pow(x[i], j));
      X.push(row);
      Y.push([y[i]]);
    }
    // Normal equation (X^T X) beta = X^T Y
    const XT = X[0].map((_,j)=>X.map(r=>r[j]));
    const XTX = XT.map(r=>XT.map((_,j)=>r.reduce((s,v,k)=>s+v*X[k][j],0)));
    const XTY = XT.map(r=>r.reduce((s,v,k)=>s+v*Y[k][0],0));
    // Solve with Gaussian elimination
    const m = XTX.length;
    for(let i=0;i<m;i++){
      let max=i; for(let j=i+1;j<m;j++) if(Math.abs(XTX[j][i])>Math.abs(XTX[max][i])) max=j;
      [XTX[i],XTX[max]]=[XTX[max],XTX[i]]; [XTY[i],XTY[max]]=[XTY[max],XTY[i]];
      for(let j=i+1;j<m;j++){
        const f=XTX[j][i]/XTX[i][i];
        for(let k=i;k<m;k++) XTX[j][k]-=f*XTX[i][k];
        XTY[j]-=f*XTY[i];
      }
    }
    const beta=new Array(m);
    for(let i=m-1;i>=0;i--){
      let sum=0; for(let j=i+1;j<m;j++) sum+=XTX[i][j]*beta[j];
      beta[i]=(XTY[i]-sum)/XTX[i][i];
    }
    return beta;
  }
  global.polyfit=polyfit;
})(typeof window!=='undefined'?window:this);
